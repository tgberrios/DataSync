hay que anadir una columna notes varchart a catalog al DDL y quitar  la otra de canditate columns
y mostrar notes en el catalog
tambien aplicar la nueva tabla de logs en casa

Enfocar esfuerzos en:
Mejorar queries existentes
Optimizar Ã­ndices
Agregar mÃ¡s mÃ©tricas Ãºtiles
Mejorar la UI/UX


For PostgreSQL we try current_setting('cluster_name', true) then inet_server_addr(). esto hay que quitarlo

CDC incremental funcionando

el error de las conexiones me imagino que es cuando falla un query se queda infinito haciendo retry 

TODAS LAS CONSULTAS TIENEN QUE SER SEPARADAS NO PUEDEN SER ANIDADAS
con max de 3 retries en todas las conexiones

creo que el componente que mas conexiones usa en @CatalogManager



En MariaDBToPostgres.h (5 lugares):
LÃ­nea 1200: Reset para re-sincronizaciÃ³n completa
LÃ­nea 1262: Reset para tablas OFFSET
LÃ­nea 1393: Reset para tablas RESET
LÃ­nea 2080: Reset en procesamiento paralelo
LÃ­nea 2156: Reset en procesamiento paralelo
En MSSQLToPostgres.h (3 lugares):
LÃ­nea 874: Reset para re-sincronizaciÃ³n completa
LÃ­nea 933: Reset para tablas OFFSET
LÃ­nea 1080: Reset para tablas RESET
En catalog_manager.h (2 lugares):
LÃ­nea 103: Reset para tablas inactivas
LÃ­nea 243: Reset para tablas que necesitan FULL_LOAD

âœ… CONCLUSIÃ“N:
SÃ, AMBOS ARCHIVOS ESTÃN USANDO SOLO PROCESAMIENTO PARALELO porque StreamingData.h llama a las funciones *Parallel() directamente.
PERO hay cÃ³digo legacy singular en MSSQLToPostgres.h que estÃ¡ sin usar pero presente.
Â¿Quieres que limpie MSSQLToPostgres.h para que sea consistente con MariaDBToPostgres.h?
Es decir, que la funciÃ³n transferDataMSSQLToPostgres() solo redirija a transferDataMSSQLToPostgresParallel(), y mover el cÃ³digo singular a una funciÃ³n *Old() o eliminarlo completamente.


TALVEZ PONERLE AL BANNER YA ABAJITO COMO RUNNING Y ASI

================================================================================
ğŸ”§ MEJORAS TÃ‰CNICAS SUGERIDAS - CATALOG MANAGER
================================================================================

ğŸ“‹ PRIORIDAD ALTA (Aplicar AHORA):
-----------------------------------
1. âœ… Crear DatabaseEngineFactory para eliminar if-else repetitivos
   - UbicaciÃ³n: include/engines/database_engine_factory.h
   - Beneficio: OCP, DRY, agregar nuevos motores sin modificar CatalogManager
   - LÃ­neas afectadas: catalog_manager.cpp lÃ­neas 79-88, 136-141

2. âœ… Mover queries directos a MetadataRepository
   - updateClusterNames(): lÃ­neas 38-43 â†’ repo_->getTablesWithoutClusterName()
   - validateSchemaConsistency(): lÃ­neas 62-69 â†’ repo_->getActiveTables()
   - getTableSize(): lÃ­neas 103-118 â†’ repo_->getTableSize()
   - Beneficio: SRP, mejor testabilidad, menor acoplamiento

3. âœ… Loguear o remover variables no usadas
   - deactivateNoDataTables(): lÃ­neas 28-29 (noDataCount, skipCount)
   - Beneficio: Claridad del cÃ³digo, mejor observabilidad

4. âœ… Remover includes de implementaciones concretas
   - Cambiar includes de mariadb_engine.h, mssql_engine.h, postgres_engine.h
   - Solo incluir engines/database_engine.h (interface)
   - Usar forward declarations si es necesario
   - Beneficio: Menor acoplamiento, compilaciÃ³n mÃ¡s rÃ¡pida

ğŸ“‹ PRIORIDAD MEDIA (Aplicar DESPUÃ‰S):
--------------------------------------
5. ğŸ”„ Batch getTableSize() para eficiencia
   - Crear MetadataRepository::getTableSizesBatch()
   - Cambiar N queries individuales por 1 query batch
   - Beneficio: Performance (crÃ­tico con >100 tablas)

6. ğŸ§ª Agregar interfaces para mejor testabilidad
   - IMetadataRepository interface
   - ICatalogCleaner interface
   - Beneficio: Unit testing sin BD real

7. ğŸ”’ Manejo de concurrencia
   - Agregar locks/semÃ¡foros si mÃºltiples instancias
   - Considerar tabla de "catalog_locks" en metadata
   - Beneficio: Evitar race conditions

8. ğŸ“Š Agregar mÃ©tricas de observabilidad
   - Tiempo de ejecuciÃ³n por operaciÃ³n
   - Tablas procesadas/fallidas
   - Enviar a MetricsCollector
   - Beneficio: Monitoreo en producciÃ³n

ğŸ“‹ PRIORIDAD BAJA (Nice to have):
----------------------------------
9. ğŸ“ Hacer cleanCatalog() transaccional (evaluar necesidad)
10. â™»ï¸ Extraer transformaciÃ³n a lowercase a utilidad
11. ğŸ“ˆ Agregar progress reporting para operaciones largas

================================================================================

================================================================================
ğŸ”§ MEJORAS TÃ‰CNICAS SUGERIDAS - CORE (Config.h + logger.h)
================================================================================

ğŸ“‹ Config.h - PRIORIDAD CRÃTICA:
---------------------------------
âœ… 1. SEGURIDAD: Eliminar password hardcodeado [COMPLETADO]
   - âœ… Password NO estÃ¡ hardcodeado en cÃ³digo
   - âœ… Se carga desde config.json (excluido de git)
   - âœ… Soporta variables de entorno como fallback
   - âœ… MÃ©todo setForTesting() disponible para tests

âœ… 2. Cargar configuraciÃ³n desde archivo [COMPLETADO]
   - âœ… DatabaseConfig::loadFromFile("config.json") implementado
   - âœ… Usa librerÃ­a json.hpp
   - âœ… Permite diferentes configs por ambiente
   - âœ… Se llama en main.cpp al inicio

âœ… 3. Hacer variables privadas con getters [COMPLETADO]
   - âœ… Variables privadas con underscore
   - âœ… Getters const implementados
   - âœ… EncapsulaciÃ³n correcta
   - âœ… Cambio de struct a class

ğŸŸ¡ 4. Separar configuraciones en archivos distintos
   - database_config.h (DatabaseConfig)
   - sync_config.h (SyncConfig)
   - database_defaults.h (DatabaseDefaults)
   - Beneficio: SRP, ISP, compilaciÃ³n mÃ¡s rÃ¡pida

ğŸŸ¡ 5. Agregar validaciÃ³n en SyncConfig setters
   - Validar rangos (MIN/MAX para chunk_size, workers, etc.)
   - Prevenir valores invÃ¡lidos
   - Beneficio: Robustez

âœ… 6. Remover include innecesario [COMPLETADO]
   - âœ… Config.cpp NO incluye logger.h innecesariamente

ğŸ“‹ logger.h - PRIORIDAD ALTA:
-----------------------------
ğŸ”´ 1. Dividir God Object en clases especializadas
   - ILogWriter (interface)
   - FileLogWriter (archivo)
   - DatabaseLogWriter (BD)
   - LogRotator (rotaciÃ³n)
   - LogFormatter (formateo)
   - LogLevelConverter / LogCategoryConverter (conversiones)
   - Beneficio: SRP, testabilidad, mantenibilidad

ğŸ”´ 2. Eliminar cÃ³digo duplicado en writeLog()
   - Formateo de log estÃ¡ duplicado en 2 lugares
   - Extraer a mÃ©todo formatLogMessage()
   - LÃ­neas: 214-222 y 225-233
   - Beneficio: DRY, mantenibilidad

ğŸŸ¡ 3. Usar mapas para conversiones en lugar de if-chains
   - stringToCategory(): 11 if statements â†’ std::unordered_map
   - stringToLogLevel(): 7 if statements â†’ std::unordered_map
   - Beneficio: O(1) vs O(n), mÃ¡s mantenible

ğŸŸ¡ 4. Simplificar API pÃºblica
   - De 35+ mÃ©todos a ~8 mÃ©todos con parÃ¡metros opcionales
   - Usar defaults para function y category
   - Beneficio: ISP, API mÃ¡s clara

ğŸŸ¡ 5. Crear interfaz ILogger para testabilidad
   - Permitir mockear en unit tests
   - Inyectar dependencias
   - Beneficio: Testeable sin filesystem/BD real

ğŸŸ¢ 6. Considerar usar librerÃ­a de logging existente
   - spdlog (header-only, rÃ¡pido, thread-safe)
   - Beneficio: Probado en batalla, menos cÃ³digo propio

================================================================================

================================================================================
ğŸ”§ MEJORAS TÃ‰CNICAS SUGERIDAS - EXPORT (DDLExporter.h) - 1318 lÃ­neas
================================================================================

ğŸ“Š ESTADO ACTUAL: ğŸ”´ RIESGOSO (3.5/10)
- 27% cÃ³digo duplicado (~361 lÃ­neas)
- Memory leaks potenciales (6 early returns sin RAII)
- SQL Injection vulnerable (usa escapeSQL)
- MÃ©todos >500 lÃ­neas
- No reutiliza MySQLConnection, ODBCConnection, ConnectionStringParser
========================================

ğŸ“‹ PRIORIDAD CRÃTICA (Fix URGENTE - Esta Semana):
-------------------------------------------------
ğŸ”´ 1. MEMORY LEAKS: Usar MySQLConnection RAII
   - Archivo: DDLExporter.cpp lÃ­neas 212-252 (exportMariaDBDDL)
   - Problema: 6 early returns con mysql_close manual - prone a leaks
   - SoluciÃ³n: Usar MySQLConnection wrapper ya existente
   - Beneficio: Exception-safe, no leaks, ~40 lÃ­neas menos

ğŸ”´ 2. RESOURCE LEAKS: Usar ODBCConnection RAII
   - Archivo: DDLExporter.cpp lÃ­neas 764-800+ (exportMSSQLDDL)
   - Problema: GestiÃ³n manual de SQLHENV y SQLHDBC handles
   - SoluciÃ³n: Usar ODBCConnection wrapper ya existente
   - Beneficio: Exception-safe, no leaks, ~80 lÃ­neas menos

ğŸ”´ 3. DUPLICACIÃ“N: Usar ConnectionStringParser
   - Archivo: DDLExporter.cpp
     - exportMariaDBDDL: lÃ­neas 176-202 (26 lÃ­neas)
     - exportMSSQLDDL: lÃ­neas 706-732 (26 lÃ­neas)
   - Problema: Parseo manual duplicado 2 veces
   - SoluciÃ³n: auto params = ConnectionStringParser::parse(connStr);
   - Beneficio: DRY, ~52 lÃ­neas eliminadas

ğŸ”´ 4. DUPLICACIÃ“N: Eliminar escapeSQL() duplicado
   - Archivo: DDLExporter.cpp lÃ­neas 1295-1303
   - Problema: EXACTAMENTE IGUAL al de database_engine.h
   - SoluciÃ³n: Eliminar de DDLExporter, usar el de database_engine.h
   - Beneficio: DRY, ~9 lÃ­neas eliminadas

ğŸ”´ 5. SQL INJECTION: Queries vulnerables
   - Archivos: DDLExporter.cpp mÃºltiples lugares (lÃ­neas 257, 440, 457, 458, etc.)
   - Problema: Usa escapeSQL() que NO es suficiente
   - SoluciÃ³n: Usar mysql_real_escape_string() para MariaDB
   - Impacto: VULNERABILIDAD DE SEGURIDAD

ğŸ“‹ PRIORIDAD ALTA (Esta Semana):
--------------------------------
ğŸŸ¡ 6. DUPLICACIÃ“N: Consolidar funciones save*DDL()
   - Archivos: DDLExporter.cpp
     - saveTableDDL: lÃ­neas 1130-1190
     - saveIndexDDL: lÃ­neas 1192-1221
     - saveConstraintDDL: lÃ­neas 1223-1252
     - saveFunctionDDL: lÃ­neas 1254-1289
   - Problema: 4 funciones con 85% cÃ³digo duplicado (~180 lÃ­neas)
   - SoluciÃ³n: Crear saveDDL() genÃ©rica con parÃ¡metro subfolder
   - Beneficio: DRY, ~140 lÃ­neas eliminadas

ğŸŸ¡ 7. SRP VIOLATION: Query directo en getSchemasFromCatalog()
   - Archivo: DDLExporter.cpp lÃ­neas 61-92
   - Problema: Query directo sin usar MetadataRepository
   - SoluciÃ³n: repo->getActiveSchemas()
   - Beneficio: SRP, reutilizaciÃ³n, testabilidad

ğŸŸ¡ 8. DUPLICACIÃ“N: Eliminar funciones create*Folder()
   - Archivos: DDLExporter.cpp lÃ­neas 115-168 (4 funciones casi idÃ©nticas)
   - Problema: createClusterFolder, createEngineFolder, createDatabaseFolder, createSchemaFolder
   - SoluciÃ³n: Usar std::filesystem::path con operator/ 
   - Beneficio: 4 funciones â†’ 1, ~60 lÃ­neas eliminadas

ğŸŸ¡ 9. Variables no usadas en exportAllDDL()
   - Archivo: DDLExporter.cpp lÃ­neas 17-18, 36-37, 40-42
   - Variables: successCount, errorCount, duration (calculadas pero no logueadas)
   - SoluciÃ³n: Loguear al final del proceso
   - Beneficio: Mejor observabilidad

ğŸŸ¡ 10. MÃ‰TODOS GIGANTES: Dividir exportMariaDBDDL()
   - Archivo: DDLExporter.cpp lÃ­neas 170-359 (~190 lÃ­neas)
   - Problema: MÃ©todo hace demasiadas cosas
   - SoluciÃ³n: Dividir en exportMariaDBTables(), exportMariaDBIndexes(), etc.
   - Beneficio: KISS, legibilidad, testabilidad

ğŸŸ¡ 11. MÃ‰TODOS GIGANTES: Dividir exportMSSQLDDL()
   - Archivo: DDLExporter.cpp lÃ­neas 696-1100+ (~400+ lÃ­neas)
   - Problema: MÃ©todo hace demasiadas cosas
   - SoluciÃ³n: Dividir en mÃ©todos especializados
   - Beneficio: KISS, legibilidad

ğŸ“‹ PRIORIDAD MEDIA:
-------------------
ğŸŸ¢ 12. PERFORMANCE: Optimizar sanitizeFileName()
   - Archivo: DDLExporter.cpp lÃ­neas 1305-1318
   - Problema: 10 iteraciones sobre string (10 Ã— O(n))
   - SoluciÃ³n: 1 iteraciÃ³n con find de invalidChars
   - Beneficio: ~10x mÃ¡s rÃ¡pido

ğŸŸ¢ 13. Crear interfaces para testabilidad
   - ISchemaExporter, IFileWriter interfaces
   - Permitir mocking en tests
   - Beneficio: Testeable sin BD/filesystem real

ğŸŸ¢ 14. Extraer construcciÃ³n de paths a helper
   - buildExportPath() reutilizable
   - Elimina concatenaciÃ³n manual repetida
   - Beneficio: DRY, menos errores

ğŸŸ¢ 15. Remover struct ODBCHandles no usado
   - Archivo: DDLExporter.h lÃ­neas 11-14
   - Declarado pero nunca usado
   - Beneficio: CÃ³digo mÃ¡s limpio

ğŸ“‹ REFACTORING PROFUNDO (Futuro):
----------------------------------
ğŸŸ¢ 16. Dividir DDLExporter en clases especializadas
   - DDLExporter (orquestador)
   - MariaDBDDLExtractor (extrae DDL MariaDB)
   - MSSQLDDLExtractor (extrae DDL MSSQL)
   - DDLFileWriter (escribe archivos)
   - Beneficio: SRP, OCP, testabilidad

ğŸŸ¢ 17. Usar Strategy pattern para exportadores
   - Registrar exportadores por motor de BD
   - Extensible sin modificar DDLExporter
   - Beneficio: OCP

âœ… LO QUE SÃ ESTÃ BIEN (No tocar):
----------------------------------
âœ… DelegaciÃ³n a export*Views/Procedures/Functions (estructura clara)
âœ… SanitizaciÃ³n de filenames (previene path traversal)
âœ… Manejo de errores con try-catch
âœ… Logging de errores consistente
âœ… Uso de std::filesystem (moderno)

ğŸ“Š ESTADÃSTICAS DE DUPLICACIÃ“N:
-------------------------------
- Parseo connection strings: ~52 lÃ­neas (4%)
- escapeSQL duplicado: ~9 lÃ­neas (0.7%)
- GestiÃ³n MySQL manual: ~40 lÃ­neas (3%)
- GestiÃ³n ODBC manual: ~80 lÃ­neas (6%)
- Funciones save*: ~180 lÃ­neas (14%)
TOTAL DUPLICADO: ~361 lÃ­neas (27% del archivo)

REDUCCIÃ“N POTENCIAL: 1318 â†’ ~950 lÃ­neas (-28%)

================================================================================

================================================================================
ğŸ”§ MEJORAS TÃ‰CNICAS SUGERIDAS - GOVERNANCE (DataGovernance + DataQuality) - 2178 lÃ­neas
================================================================================

ğŸ“Š ESTADO ACTUAL:
- DataGovernance: ğŸ”´ RIESGOSO (2.8/10) - God Object, if-chains gigantes
- DataQuality: ğŸŸ¡ MEJORABLE (5.6/10) - N+1 query problem crÃ­tico
========================================

ğŸ“‹ PRIORIDAD CRÃTICA (Fix URGENTE - Esta Semana):
-------------------------------------------------
ğŸ”´ 1. PERFORMANCE CRÃTICO: N+1 Query Problem en checkNullCounts()
   - Archivo: DataQuality.cpp lÃ­neas 224-285
   - Problema: Hace 1 query por columna (N+1 queries donde N = columnas)
   - Tabla con 50 columnas = 51 queries (1 + 50)
   - SoluciÃ³n: Usar COUNT(*) FILTER (WHERE col IS NULL) en 1 query
   - Beneficio: N+1 queries â†’ 1 query, ~50x mÃ¡s rÃ¡pido
   - IMPACTO: CRÃTICO para performance

ğŸ”´ 2. DUPLICACIÃ“N: escapeSQL() - TERCERA VEZ
   - Archivo: DataGovernance.cpp lÃ­neas 763-771
   - Ya existe en: database_engine.h, DDLExporter.cpp
   - Problema: VIOLACIÃ“N GRAVE de DRY - misma funciÃ³n 3 veces
   - SoluciÃ³n: Eliminar de DataGovernance, usar de database_engine.h
   - Beneficio: DRY, ~9 lÃ­neas eliminadas

ğŸ”´ 3. DUPLICACIÃ“N: getCurrentTimestamp() - SEGUNDA VEZ
   - Archivo: DataGovernance.cpp lÃ­neas 773-784
   - Ya existe en: Logger::getCurrentTimestamp()
   - Problema: DUPLICACIÃ“N - lÃ³gica idÃ©ntica
   - SoluciÃ³n: Usar Logger::getCurrentTimestamp() o mover a utils/
   - Beneficio: DRY, ~12 lÃ­neas eliminadas

ğŸ”´ 4. SQL INJECTION: Queries con escapeSQL
   - Archivo: DataGovernance.cpp lÃ­neas 178-181, 236-237, 244-245, etc.
   - Problema: Usa escapeSQL() vulnerable en ~10 lugares
   - SoluciÃ³n: Usar prepared statements con exec_params() o txn.quote()
   - Impacto: VULNERABILIDAD DE SEGURIDAD

ğŸ”´ 5. IF-CHAINS MONSTRUOSOS: determine*() functions - 388 LÃNEAS
   - Archivos: DataGovernance.cpp
     - determineDataCategory: lÃ­neas 833-981 (148 lÃ­neas!)
     - determineBusinessDomain: lÃ­neas 1000-1100 (~100 lÃ­neas)
     - determineSensitivityLevel: lÃ­neas 1100-1180 (~80 lÃ­neas)
     - determineDataClassification: lÃ­neas 1180-1240 (~60 lÃ­neas)
   - Problema: 120+ if-chains con .find(), lÃ³gica hardcoded, viola OCP
   - SoluciÃ³n: Externalizar a governance_rules.json + DataClassifier
   - Beneficio: 388 lÃ­neas â†’ ~50 lÃ­neas, configurable, extensible, testeable

ğŸ“‹ PRIORIDAD ALTA (Esta Semana):
--------------------------------
ğŸŸ¡ 6. DUPLICACIÃ“N: TransformaciÃ³n a lowercase (6 veces)
   - Archivos: DataGovernance.cpp (5 veces), DataQuality.cpp (1+ veces)
   - CÃ³digo: std::transform(str.begin(), str.end(), str.begin(), ::tolower);
   - SoluciÃ³n: Crear utils/string_utils.h con funciÃ³n toLower()
   - Beneficio: DRY, ~30 lÃ­neas eliminadas

ğŸŸ¡ 7. DUPLICACIÃ“N: ValidaciÃ³n tabla exists (4 veces)
   - Archivo: DataQuality.cpp en checkNullCounts, checkDuplicates, checkConstraints
   - CÃ³digo: Query a information_schema.tables repetida
   - SoluciÃ³n: FunciÃ³n helper tableExists(txn, schema, table)
   - Beneficio: DRY, ~40 lÃ­neas eliminadas

ğŸŸ¡ 8. SIN INYECCIÃ“N: 7 conexiones directas en DataGovernance
   - LÃ­neas: 19, 113, 165, storeMetadata, updateExistingMetadata, generateReport
   - CÃ³digo: pqxx::connection conn(DatabaseConfig::getPostgresConnectionString());
   - SoluciÃ³n: Aceptar conexiÃ³n como parÃ¡metro o usar MetadataRepository
   - Beneficio: Testabilidad, SRP

ğŸŸ¡ 9. FUNCIONES TRIVIALES: 7 calculate*Score() de 1-2 lÃ­neas
   - Archivo: DataGovernance.cpp lÃ­neas 1391-1420
   - Problema: calculateCompletenessScore, calculateAccuracyScore, etc. (7 funciones)
   - Cada una: return 100.0 - (metadata.campo * factor);
   - SoluciÃ³n: 1 funciÃ³n con struct QualityWeights configurable
   - Beneficio: 7 funciones â†’ 1, factores configurables

ğŸŸ¡ 10. STRUCT GRANDE: TableMetadata con 60 campos
   - Archivo: DataGovernance.h lÃ­neas 11-60
   - Problema: Mezcla 5 concerns diferentes (basic, quality, classification, governance, usage)
   - SoluciÃ³n: Dividir en sub-structs: BasicMetadata, QualityScores, Classification, etc.
   - Beneficio: SRP, mÃ¡s fÃ¡cil de construir/validar

ğŸŸ¡ 11. cleanSchemaNameForPostgres funciÃ³n global
   - Archivo: DataQuality.cpp lÃ­neas 4-35
   - Problema: FunciÃ³n global (namespace pollution), llamada 6 veces
   - SoluciÃ³n: Mover a utils/string_utils.h como mÃ©todo de clase
   - Beneficio: Mejor organizaciÃ³n

ğŸ“‹ PRIORIDAD MEDIA:
-------------------
ğŸŸ¢ 12. Externalizar configuraciÃ³n de pesos/factores
   - Factores 0.1, 0.5, 0.3, etc. hardcoded
   - Crear governance_config.json con QualityWeights
   - Beneficio: ConfiguraciÃ³n flexible sin recompilar

ğŸŸ¢ 13. Usar MetadataRepository para queries
   - getSchemasFromCatalog hace query directo
   - DeberÃ­a usar MetadataRepository existente
   - Beneficio: DRY, SRP

ğŸŸ¢ 14. Consolidar queries a information_schema
   - MÃºltiples queries similares con pequeÃ±as variaciones
   - Extraer a funciones helper
   - Beneficio: DRY

ğŸŸ¢ 15. Agregar interfaces para testabilidad
   - ITableAnalyzer, IDataClassifier interfaces
   - Permitir mocking
   - Beneficio: Unit testing sin BD real

ğŸŸ¢ 16. Optimizar checkDuplicates similar a checkNullCounts
   - Probablemente tiene mismo N+1 problem
   - Revisar y optimizar
   - Beneficio: Performance

ğŸ“‹ REFACTORING PROFUNDO (Futuro):
----------------------------------
ğŸŸ¢ 17. Dividir DataGovernance en clases especializadas
   - TableDiscoverer, StructureAnalyzer, QualityAnalyzer, etc.
   - Cada clase una responsabilidad
   - Beneficio: SRP, testabilidad, mantenibilidad

ğŸŸ¢ 18. Implementar DataClassifier con reglas externas
   - Cargar keywords desde governance_rules.json
   - Sistema de scoring por coincidencias
   - Extensible sin modificar cÃ³digo
   - Beneficio: OCP, configurabilidad

âœ… LO QUE SÃ ESTÃ BIEN (No tocar):
----------------------------------
âœ… DataQuality acepta conexiÃ³n inyectada (buen diseÃ±o)
âœ… Manejo de errores con try-catch consistente
âœ… Logging de errores detallado
âœ… Uso de prepared statements en algunos lugares (txn.quote)
âœ… ValidaciÃ³n de parÃ¡metros de entrada
âœ… QualityMetrics struct bien diseÃ±ado (tamaÃ±o razonable)

ğŸ“Š ESTADÃSTICAS CLAVE:
----------------------
DataGovernance:
- LÃ­neas totales: 1548
- If-chains de clasificaciÃ³n: 388 lÃ­neas (25%)
- CÃ³digo duplicado: ~50 lÃ­neas
- Funciones determine*: 5 funciones, 388 lÃ­neas total
- Funciones calculate*Score: 7 funciones triviales
- Conexiones directas: 7 ocurrencias

DataQuality:
- LÃ­neas totales: 630
- N+1 queries: checkNullCounts (probablemente tambiÃ©n checkDuplicates)
- cleanSchemaNameForPostgres: 6 llamadas
- ValidaciÃ³n tabla exists: 4 duplicaciones

REDUCCIÃ“N POTENCIAL DataGovernance: 1548 â†’ ~1000 lÃ­neas (-35%)
REDUCCIÃ“N POTENCIAL DataQuality: 630 â†’ ~580 lÃ­neas (-8%)

================================================================================

================================================================================
ğŸ”§ MEJORAS TÃ‰CNICAS SUGERIDAS - METRICS (MetricsCollector) - 591 lÃ­neas
================================================================================

ğŸ“Š ESTADO ACTUAL: ğŸŸ¡ ACEPTABLE CON MEJORAS (5.8/10)
- escapeSQL duplicado CUARTA VEZ
- getCurrentTimestamp duplicado TERCERA VEZ
- Nested loops O(nÂ²) en 3 mÃ©todos - no escala con muchas tablas
- 8 conexiones directas - overhead innecesario
========================================

ğŸ“‹ PRIORIDAD CRÃTICA (Fix URGENTE - Esta Semana):
-------------------------------------------------
ğŸ”´ 1. DUPLICACIÃ“N: escapeSQL() - CUARTA VEZ
   - Archivo: MetricsCollector.cpp lÃ­neas 445-453
   - Ya existe en: database_engine.h, DDLExporter.cpp, DataGovernance.cpp
   - Problema: VIOLACIÃ“N EXTREMA de DRY - misma funciÃ³n 4 veces
   - SoluciÃ³n: Eliminar de MetricsCollector, usar de database_engine.h
   - Beneficio: DRY, ~9 lÃ­neas eliminadas

ğŸ”´ 2. DUPLICACIÃ“N: getCurrentTimestamp() - TERCERA VEZ
   - Archivo: MetricsCollector.cpp lÃ­neas 455-466
   - Ya existe en: Logger::getCurrentTimestamp(), DataGovernance::getCurrentTimestamp()
   - Problema: DUPLICACIÃ“N - lÃ³gica idÃ©ntica 3 veces
   - SoluciÃ³n: Eliminar de MetricsCollector, usar Logger::getCurrentTimestamp()
   - Beneficio: DRY, ~12 lÃ­neas eliminadas

ğŸ”´ 3. PERFORMANCE CRÃTICO: Nested loops O(nÂ²) - 3 MÃ‰TODOS
   - Archivos: MetricsCollector.cpp
     - collectPerformanceMetrics: lÃ­neas 229-244 (O(n Ã— m))
     - collectMetadataMetrics: lÃ­neas 274-304 (O(n Ã— m))
     - collectTimestampMetrics: lÃ­neas 330-342 (O(n Ã— m))
   - Problema: Nested loops con comparaciÃ³n de strings
   - 100 tablas Ã— 100 resultados = 10,000 comparaciones innecesarias
   - SoluciÃ³n: Usar std::unordered_map para O(1) lookup
   - Beneficio: O(nÂ²) â†’ O(n), ~100x mÃ¡s rÃ¡pido con 100 tablas
   - IMPACTO: CRÃTICO para escalabilidad

ğŸ“‹ PRIORIDAD ALTA (Esta Semana):
--------------------------------
ğŸŸ¡ 4. CONEXIONES SIN INYECCIÃ“N: 8 conexiones directas
   - LÃ­neas: 27, 84, 204, 255, 315, 353, 398, 506
   - CÃ³digo: pqxx::connection conn(DatabaseConfig::getPostgresConnectionString());
   - Problema: 8 conexiones diferentes cuando podrÃ­a ser 1
   - SoluciÃ³n: Pasar 1 conexiÃ³n como parÃ¡metro a todos los mÃ©todos
   - Beneficio: Performance, testabilidad, posibilidad de transacciÃ³n

ğŸŸ¡ 5. DUPLICACIÃ“N: Mapeo de status/transfer_type (2 veces)
   - Archivos: MetricsCollector.cpp
     - collectTransferMetrics: lÃ­neas 153-179
     - collectMetadataMetrics: lÃ­neas 282-298
   - Problema: LÃ³gica de mapeo duplicada con variaciones
   - SoluciÃ³n: Crear StatusMapper helper class
   - Beneficio: DRY, ~30 lÃ­neas eliminadas

ğŸŸ¡ 6. Variables calculadas NO USADAS en generateMetricsReport()
   - Archivo: MetricsCollector.cpp lÃ­neas 419-435
   - Variables: totalTables, successfulTransfers, failedTransfers, pendingTransfers,
     totalRecords, totalBytes, avgMemoryUsed, totalIOOperations, successRate, totalMB
   - Problema: 10 variables calculadas pero ninguna se usa/loguea/retorna
   - SoluciÃ³n: Loguear todas las estadÃ­sticas al final
   - Beneficio: Mejor observabilidad, justifica el cÃ¡lculo

ğŸŸ¡ 7. SQL INJECTION: En calculateBytesTransferred()
   - Archivo: MetricsCollector.cpp lÃ­neas 517-519
   - Problema: Usa escapeSQL() vulnerable
   - SoluciÃ³n: Usar exec_params con prepared statement
   - Beneficio: Seguridad

ğŸŸ¡ 8. DUPLICACIÃ“N: TransformaciÃ³n lowercase (2 veces mÃ¡s)
   - Archivo: MetricsCollector.cpp lÃ­neas 509-514
   - Ya duplicado en: DataGovernance (5 veces), DataQuality (1+ veces)
   - SoluciÃ³n: Usar toLower() de utils/string_utils.h (cuando se cree)
   - Beneficio: DRY

ğŸ“‹ PRIORIDAD MEDIA:
-------------------
ğŸŸ¢ 9. Dividir mÃ©todos largos
   - collectTransferMetrics: ~120 lÃ­neas
   - SoluciÃ³n: Dividir en fetchData() + processData()
   - Beneficio: KISS, legibilidad

ğŸŸ¢ 10. Crear interface IMetricsCollector
   - Permitir mocking en tests
   - Beneficio: Testeable sin BD real

ğŸŸ¢ 11. Considerar usar batch processing
   - saveMetricsToDatabase hace 1 query por mÃ©trica
   - PodrÃ­a usar COPY o VALUES bulk insert
   - Beneficio: Performance con muchas tablas

ğŸŸ¢ 12. Remover empty else block
   - LÃ­nea 437-438 (else vacÃ­o)
   - Beneficio: CÃ³digo mÃ¡s limpio

âœ… LO QUE SÃ ESTÃ BIEN (No tocar):
----------------------------------
âœ… Usa prepared statements en saveMetricsToDatabase (exec_params) - SEGURO
âœ… ValidaciÃ³n de datos (null checks, empty checks, rangos negativos)
âœ… Uso de FILTER clause en SQL (moderno, eficiente)
âœ… Uso de UPSERT con ON CONFLICT (idempotente)
âœ… Struct TransferMetrics bien diseÃ±ado (29 campos razonables)
âœ… API pÃºblica simple (2 mÃ©todos principales)
âœ… Manejo de errores con try-catch consistente
âœ… Logging de errores detallado
âœ… Reserve memory para vector (optimizaciÃ³n)
âœ… LEFT JOINs correctos para mÃ©tricas opcionales

ğŸ“Š ESTADÃSTICAS CLAVE:
----------------------
- LÃ­neas totales: 591
- escapeSQL duplicado: CUARTA VEZ (~9 lÃ­neas)
- getCurrentTimestamp duplicado: TERCERA VEZ (~12 lÃ­neas)
- Nested loops O(nÂ²): 3 ocurrencias
- Mapeo status duplicado: 2 veces (~30 lÃ­neas)
- Conexiones directas: 8 ocurrencias
- Variables no usadas: 10 en generateMetricsReport
- TransformaciÃ³n lowercase: 2 veces

REDUCCIÃ“N POTENCIAL: 591 â†’ ~540 lÃ­neas (-9%)
PERO GANANCIA PRINCIPAL: ~100x mÃ¡s rÃ¡pido con optimizaciÃ³n de nested loops

================================================================================

================================================================================
ğŸ”§ MEJORAS TÃ‰CNICAS SUGERIDAS - UTILS (connection_utils + cluster_name_resolver) - 310 lÃ­neas
================================================================================

ğŸ“Š ESTADO ACTUAL: âœ… EXCELENTE (9.0/10)
- connection_utils: âœ… EXCELENTE (9.8/10) - DiseÃ±o perfecto, cÃ³digo moderno
- cluster_name_resolver: âœ… MUY BUENO (8.1/10) - Bien diseÃ±ado, mejoras menores
- NO HAY PROBLEMAS CRÃTICOS - Esta es una de las mejores carpetas del proyecto
========================================

ğŸ“‹ PRIORIDAD ALTA (Cuando se tenga tiempo):
-------------------------------------------
ğŸŸ¡ 1. CREAR string_utils.h para eliminar transformaciones duplicadas
   - Crear: include/utils/string_utils.h
   - Funciones: toUpper(), toLower(), trim()
   - Beneficio: Reutilizable en TODO el proyecto
   - Lugares que lo usarÃ­an:
     - cluster_name_resolver.cpp: 7 veces
     - DataGovernance.cpp: 5 veces
     - DataQuality.cpp: 1+ veces
     - MetricsCollector.cpp: 2 veces
     - catalog_manager.cpp: varias veces
     TOTAL: ~20+ lugares en el proyecto

ğŸŸ¡ 2. Simplificar extractHostname() reutilizando ConnectionStringParser
   - Archivo: cluster_name_resolver.cpp lÃ­neas 147-172 (25 lÃ­neas)
   - Problema: Duplica parsing que ya existe en ConnectionStringParser
   - SoluciÃ³n: auto params = ConnectionStringParser::parse(connStr); return params->host;
   - Beneficio: DRY, ~22 lÃ­neas eliminadas

ğŸŸ¡ 3. Simplificar resolvePostgreSQL segÃºn TODO.txt
   - Archivo: cluster_name_resolver.cpp lÃ­neas 119-144
   - TODO dice: "quitar current_setting('cluster_name') e inet_server_addr()"
   - Problema: Query a BD innecesario, usa fallback de todos modos
   - SoluciÃ³n: Usar getClusterNameFromHostname(params->host) directamente
   - Beneficio: MÃ¡s simple, sin query, consistente

ğŸ“‹ PRIORIDAD BAJA (Opcional):
-----------------------------
ğŸŸ¢ 4. Hacer getClusterNameFromHostname() configurable
   - Archivo: cluster_name_resolver.cpp lÃ­neas 175-219 (45 lÃ­neas)
   - Problema: LÃ³gica hardcoded - agregar ambiente requiere modificar cÃ³digo
   - SoluciÃ³n: Usar std::unordered_map con keywords por ambiente
   - Beneficio: OCP, mÃ¡s fÃ¡cil agregar entornos
   - Trade-off: Complejidad adicional para beneficio menor

ğŸŸ¢ 5. Usar string_view en trim() para evitar copias
   - Archivo: connection_utils.cpp lÃ­neas 36-42
   - Micro-optimizaciÃ³n: usar string_view en lugar de string
   - Beneficio: Evita copia (ganancia mÃ­nima)

âœ… LO QUE SÃ ESTÃ BIEN (No tocar - PERFECTO):
---------------------------------------------
âœ… ConnectionStringParser - DISEÃ‘O EXCELENTE
   âœ… Usa std::optional<T> para manejo de errores - moderno C++17
   âœ… Usa std::string_view - eficiente, sin copias innecesarias
   âœ… Helper privado trim() - encapsulaciÃ³n correcta
   âœ… ValidaciÃ³n clara - retorna nullopt si faltan parÃ¡metros
   âœ… Maneja mÃºltiples formatos - host/SERVER, db/DATABASE
   âœ… Sin excepciones innecesarias - retorna optional
   âœ… REUTILIZADO en engines - elimina duplicaciÃ³n masiva

âœ… ClusterNameResolver - DISEÃ‘O MUY BUENO
   âœ… Usa MySQLConnection RAII wrapper - sin memory leaks
   âœ… Usa ODBCConnection RAII wrapper - sin resource leaks
   âœ… Usa ConnectionStringParser - DRY, reutiliza componente
   âœ… Exception-safe - catch-all en mÃ©todos crÃ­ticos
   âœ… MÃ©todos estÃ¡ticos - fÃ¡ciles de testear
   âœ… Fallback logic - robusto si query falla
   âœ… Sin SQL injection - no hace queries peligrosas

ğŸ“Š ESTADÃSTICAS CLAVE:
----------------------
- LÃ­neas totales: 310
- CÃ³digo duplicado: ~25 lÃ­neas (parsing en extractHostname)
- Transformaciones upper/lower: 7 veces
- TODO pendiente: Simplificar resolvePostgreSQL
- Problemas crÃ­ticos: 0
- Problemas importantes: 0
- Mejoras menores: 3

REDUCCIÃ“N POTENCIAL: 310 â†’ ~283 lÃ­neas (-9%)

CALIFICACIÃ“N GLOBAL: âœ… 9.0/10 - EXCELENTE
Esta carpeta NO requiere refactoring. Solo mejoras menores opcionales.

================================================================================

================================================================================
ğŸ”§ MEJORAS TÃ‰CNICAS SUGERIDAS - SYNC (MariaDBToPostgres.h) - 3989 LÃNEAS
================================================================================

ğŸ“Š ESTADO ACTUAL: ğŸ”´ğŸ”´ EXTREMADAMENTE RIESGOSO (2.2/10)
- HEADER-ONLY con 3989 lÃ­neas (deberÃ­a ser .h + .cpp)
- MEGA GOD OBJECT con 25+ responsabilidades diferentes
- escapeSQL() QUINTA VEZ (duplicado de nuevo)
- 52+ SQL Injection vulnerabilities
- No usa MySQLConnection, ConnectionStringParser, MetadataRepository
- ~486 lÃ­neas duplicadas (12% del archivo)
- MÃ©todos de 900 lÃ­neas
========================================

ğŸ“‹ PRIORIDAD CRÃTICA - ARQUITECTÃ“NICA (URGENTE):
------------------------------------------------
ğŸ”´ 1. HEADER-ONLY DE 4000 LÃNEAS - Separar .h y .cpp
   - Archivo: MariaDBToPostgres.h (3989 lÃ­neas)
   - Problema: TODO estÃ¡ en header - cada #include recompila 4000 lÃ­neas
   - Tiempo compilaciÃ³n EXTREMO
   - SoluciÃ³n:
     - include/sync/MariaDBToPostgres.h (~200 lÃ­neas - solo declaraciones)
     - src/sync/MariaDBToPostgres.cpp (~3800 lÃ­neas - implementaciones)
   - Beneficio: CompilaciÃ³n ~20x mÃ¡s rÃ¡pida
   - IMPACTO: CRÃTICO para desarrollo

ğŸ”´ 2. MEGA GOD OBJECT - 25+ responsabilidades
   - Una sola clase hace: parseo, conexiones, queries, transformaciÃ³n,
     bulk insert, threading, status updates, PK management, etc.
   - Problema: Viola SRP GRAVEMENTE, imposible mantener/testear
   - SoluciÃ³n: Dividir en clases especializadas:
     - MariaDBToPostgres (orquestador)
     - MariaDBConnectionManager (conexiones - usa MySQLConnection RAII)
     - MariaDBTableSetup (setup tablas)
     - MariaDBDataFetcher (queries origen)
     - DataTransformer (cleanValueForPostgres, mapeo tipos)
     - PostgreSQLBulkWriter (bulk upsert/insert)
     - SyncStatusManager (metadata - usa MetadataRepository)
     - ParallelSyncCoordinator (threads)
   - Beneficio: SRP, OCP, testabilidad, mantenibilidad

ğŸ”´ 3. DUPLICACIÃ“N: escapeSQL() - QUINTA VEZ (52+ usos)
   - Archivo: MariaDBToPostgres.h lÃ­neas 2998-3009
   - Ya existe en: database_engine.h, DDLExporter.cpp, DataGovernance.cpp, MetricsCollector.cpp
   - Usado 52+ veces solo en este archivo
   - Problema: VIOLACIÃ“N EXTREMA de DRY - misma funciÃ³n 5 veces
   - SoluciÃ³n: Eliminar, usar de database_engine.h
   - Beneficio: DRY, ~12 lÃ­neas eliminadas

ğŸ”´ 4. SQL INJECTION MASIVO: 52+ vulnerabilities
   - Archivo: MariaDBToPostgres.h mÃºltiples lÃ­neas
   - Ejemplos: 250-253, 368-370, 647, 662-663, 740, 835, 1077-1078, 1208-1209,
     1270-1271, 1362-1363, 1400-1402, 1476, 1631-1633, 2053-2055, 2063-2065,
     2201-2203, 2348-2349, 2500-2502, 2648, 2737-2739, 2807-2808, 2911, 2977,
     3116, 3182, 3254, 3372, 3735-3738, 3910, y mÃ¡s...
   - Problema: 52+ usos de escapeSQL() vulnerable
   - SoluciÃ³n: Usar prepared statements (exec_params) donde sea posible
   - IMPACTO: VULNERABILIDAD DE SEGURIDAD MASIVA

ğŸ”´ 5. NO USA MySQLConnection RAII - Memory leaks potenciales
   - Archivo: MariaDBToPostgres.h
   - getMariaDBConnection retorna MYSQL* raw (lÃ­nea 66-173)
   - 8+ mysql_close manual: lÃ­neas 142, 152, 300, 500, 1048, 1157, 1764, 2107, 2227
   - Problema: Si exception entre get y close â†’ MEMORY LEAK
   - SoluciÃ³n: Usar MySQLConnection wrapper ya existente
   - Beneficio: Exception-safe, sin leaks, ~50 lÃ­neas menos

ğŸ“‹ PRIORIDAD CRÃTICA - DUPLICACIÃ“N (Esta Semana):
-------------------------------------------------
ğŸ”´ 6. DUPLICACIÃ“N: Parseo connection string
   - Archivo: MariaDBToPostgres.h lÃ­neas 74-98 (getMariaDBConnection)
   - Ya existe: ConnectionStringParser::parse()
   - Problema: Duplica lÃ³gica completa de parsing (~25 lÃ­neas)
   - SoluciÃ³n: auto params = ConnectionStringParser::parse(connStr);
   - Beneficio: DRY, ~25 lÃ­neas eliminadas

ğŸ”´ 7. DUPLICACIÃ“N: TransformaciÃ³n toLower (25+ veces)
   - Archivo: MariaDBToPostgres.h
   - LÃ­neas: 258-260, 269-272, 383-388, 410-412, 517-519, 553-555, 626-628,
     669-671, 744-746, 804-806, 947-948, 984-986, y ~15 mÃ¡s...
   - Problema: std::transform(..., ::tolower) repetido 25+ veces
   - SoluciÃ³n: Usar toLower() de utils/string_utils.h (cuando se cree)
   - Beneficio: DRY, ~50 lÃ­neas eliminadas

ğŸ”´ 8. DUPLICACIÃ“N: Lambda sorting (3 veces idÃ©nticas)
   - Archivo: MariaDBToPostgres.h
   - LÃ­neas: 327-344 (setupTable), 899-916 (transferOld), 1806-1823 (transferParallel)
   - Problema: Lambda EXACTAMENTE IGUAL 3 veces (18 lÃ­neas Ã— 3 = 54 lÃ­neas)
   - SoluciÃ³n: Extraer a funciÃ³n/constexpr comparator reutilizable
   - Beneficio: DRY, ~36 lÃ­neas eliminadas

ğŸ”´ 9. DUPLICACIÃ“N: ConstrucciÃ³n de VALUES clause (5 veces)
   - Archivo: MariaDBToPostgres.h
   - LÃ­neas: 3103-3122 (performBulkUpsert), 3359-3377 (performBulkInsert),
     2635-2653 (batchPreparer), 3169-3186 (error handling), 3241-3258 (binary error)
   - Problema: ConstrucciÃ³n idÃ©ntica 5 veces (19 lÃ­neas Ã— 5 = 95 lÃ­neas)
   - SoluciÃ³n: Extraer a funciÃ³n buildValueClause()
   - Beneficio: DRY, ~76 lÃ­neas eliminadas

ğŸ”´ 10. DUPLICACIÃ“N: Setup de tabla lÃ³gica (2 veces)
   - Archivo: MariaDBToPostgres.h
   - LÃ­neas: 365-501 (setupTableTarget), 1912-1970 (processTableParallel)
   - Problema: Obtener columnas + mapear tipos duplicado (~100 lÃ­neas Ã— 2)
   - SoluciÃ³n: Extraer a mÃ©todo getTableSchema() reutilizable
   - Beneficio: DRY, ~100 lÃ­neas eliminadas

ğŸ“‹ PRIORIDAD CRÃTICA - MÃ‰TODOS GIGANTES:
----------------------------------------
ğŸ”´ 11. MÃ‰TODO GIGANTE: transferDataMariaDBToPostgresOld() - 900 LÃNEAS
   - Archivo: MariaDBToPostgres.h lÃ­neas 877-1779
   - Problema: UN mÃ©todo con 900 lÃ­neas - complejidad extrema
   - Imposible de mantener, testear, entender
   - SoluciÃ³n: Dividir en 10-15 mÃ©todos mÃ¡s pequeÃ±os
   - Beneficio: KISS, legibilidad, testabilidad

ğŸ”´ 12. MÃ‰TODO GIGANTE: processTableParallel() - 371 LÃNEAS
   - Archivo: MariaDBToPostgres.h lÃ­neas 1893-2264
   - Problema: MÃ©todo muy largo y complejo
   - SoluciÃ³n: Dividir en mÃ©todos focalizados
   - Beneficio: KISS, legibilidad

ğŸ“‹ PRIORIDAD ALTA:
------------------
ğŸŸ¡ 13. Usar MetadataRepository en lugar de queries directos
   - MÃºltiples queries a metadata.catalog
   - getPKStrategyFromCatalog, getPKColumnsFromCatalog, getLastProcessedPKFromCatalog
   - SoluciÃ³n: Usar MetadataRepository existente
   - Beneficio: DRY, SRP

ğŸŸ¡ 14. Extraer validaciÃ³n de parÃ¡metros duplicada
   - ValidaciÃ³n de empty strings repetida 10+ veces
   - SoluciÃ³n: Helper validateTableParams()
   - Beneficio: DRY

ğŸŸ¡ 15. Consolidar lÃ³gica de mapeo de tipos
   - CÃ³digo de mapeo VARCHAR/tipos duplicado en mÃºltiples lugares
   - LÃ­neas: 428-454, 1321-1349, 1946-1967
   - SoluciÃ³n: Extraer a TypeMapper class
   - Beneficio: DRY, ~150 lÃ­neas consolidadas

ğŸŸ¡ 16. struct TableInfo renombrar
   - Nombre genÃ©rico que colisiona con otros TableInfo
   - SoluciÃ³n: Renombrar a SyncTableInfo o MariaDBSyncTable
   - Beneficio: Claridad, evita confusiÃ³n

ğŸ“‹ PRIORIDAD MEDIA:
-------------------
ğŸŸ¢ 17. Extraer construcciÃ³n de queries
   - buildUpsertQuery, buildUpsertConflictClause podrÃ­an estar en QueryBuilder
   - Beneficio: SRP, reutilizable

ğŸŸ¢ 18. Usar connection pooling
   - Crear/destruir conexiÃ³n en cada llamada
   - SoluciÃ³n: Pool de conexiones reutilizables
   - Beneficio: Performance significativa

ğŸŸ¢ 19. Comentarios DEBUG y cÃ³digo comentado
   - MÃºltiples std::cerr comentados
   - Bloques de cÃ³digo comentado (lÃ­neas 2545-2552)
   - SoluciÃ³n: Eliminar cÃ³digo muerto
   - Beneficio: Limpieza

ğŸ“Š ESTADÃSTICAS CLAVE:
----------------------
- LÃ­neas totales: 3989 (HEADER-ONLY!)
- Responsabilidades: 25+
- MÃ©todos gigantes: transferDataMariaDBToPostgresOld (900 lÃ­neas)
- CÃ³digo duplicado estimado: ~486 lÃ­neas (12%)
- escapeSQL duplicado: QUINTA VEZ, 52+ usos
- toLower duplicado: 25+ veces
- Lambda sorting: 3 veces idÃ©nticas (54 lÃ­neas)
- ConstrucciÃ³n VALUES: 5 veces (95 lÃ­neas)
- Setup tabla: 2 veces (200 lÃ­neas)
- Parseo connection string: 1 vez (25 lÃ­neas)
- mysql_close manual: 8 ocurrencias
- SQL Injection: 52+ lugares
- TransformaciÃ³n case: 29+ veces (toUpper/toLower)

REDUCCIÃ“N POTENCIAL: 3989 â†’ ~3300 lÃ­neas (-17%)
PERO REAL BENEFICIO: Separar .h/.cpp + dividir en clases
  â†’ MariaDBToPostgres.h: ~200 lÃ­neas
  â†’ MariaDBToPostgres.cpp + helpers: ~1500 lÃ­neas (dividido en mÃºltiples archivos)
  TOTAL: ~1700 lÃ­neas vs 3989 (-57%)

CALIFICACIÃ“N: ğŸ”´ 2.2/10 - EXTREMADAMENTE RIESGOSO
REQUIERE REFACTORING ARQUITECTÃ“NICO URGENTE

================================================================================

================================================================================
ğŸ”§ MEJORAS TÃ‰CNICAS SUGERIDAS - SYNC (MSSQLToPostgres.h) - 3442 LÃNEAS
================================================================================

ğŸ“Š ESTADO ACTUAL: ğŸ”´ğŸ”´ EXTREMADAMENTE RIESGOSO (2.0/10)
- HEADER-ONLY con 3442 lÃ­neas (deberÃ­a ser .h + .cpp)
- MEGA GOD OBJECT con 20+ responsabilidades
- escapeSQL() SEXTA VEZ (duplicado de nuevo)
- 45+ SQL Injection vulnerabilities
- 70-80% cÃ³digo DUPLICADO con MariaDBToPostgres.h (~2500 lÃ­neas!)
- No usa ODBCConnection RAII - resource leaks garantizados
========================================

ğŸ“‹ PRIORIDAD CRÃTICA - DUPLICACIÃ“N ENTRE ARCHIVOS:
--------------------------------------------------
ğŸ”´ğŸ”´ 1. DUPLICACIÃ“N MASIVA: 70-80% cÃ³digo idÃ©ntico con MariaDBToPostgres.h
   - Archivos: MSSQLToPostgres.h (3442 lÃ­neas) + MariaDBToPostgres.h (3989 lÃ­neas)
   - CÃ³digo duplicado estimado: ~2500 lÃ­neas (70-80% de overlap)
   - Ejemplos de cÃ³digo IDÃ‰NTICO:
     - struct TableInfo: 100% idÃ©ntico
     - Lambda sorting: 100% idÃ©ntico (18 lÃ­neas)
     - getActiveTables(): 95% idÃ©ntico (50 lÃ­neas)
     - buildUpsertQuery(): 90% idÃ©ntico (22 lÃ­neas)
     - buildUpsertConflictClause(): 95% idÃ©ntico (20 lÃ­neas)
     - cleanValueForPostgres(): 85% similar (200 vs 103 lÃ­neas)
     - LÃ³gica TRUNCATE/RESET: 95% idÃ©ntica
     - LÃ³gica PK management: 95% idÃ©ntica
     - Parallel processing: 80% idÃ©ntico
   - SoluciÃ³n: Crear clase base DatabaseToPostgresSync con cÃ³digo comÃºn
     - DatabaseToPostgresSync (clase abstracta base) ~2000 lÃ­neas
     - MariaDBToPostgres hereda, solo especÃ­fico MariaDB ~800 lÃ­neas
     - MSSQLToPostgres hereda, solo especÃ­fico MSSQL ~700 lÃ­neas
   - Beneficio: Elimina ~2500 lÃ­neas duplicadas, bugs se arreglan 1 vez
   - IMPACTO: CRÃTICO - esta es la duplicaciÃ³n mÃ¡s grande del proyecto

ğŸ”´ 2. HEADER-ONLY DE 3442 LÃNEAS - Separar .h y .cpp
   - Archivo: MSSQLToPostgres.h (3442 lÃ­neas)
   - Problema: TODO en header - compilaciÃ³n extremadamente lenta
   - SoluciÃ³n: Dividir en .h (declaraciones) + .cpp (implementaciones)
   - Beneficio: CompilaciÃ³n ~20x mÃ¡s rÃ¡pida
   - Nota: Hacer DESPUÃ‰S de consolidar con MariaDB para no duplicar trabajo

ğŸ”´ 3. DUPLICACIÃ“N: escapeSQL() - SEXTA VEZ (45+ usos)
   - Archivo: MSSQLToPostgres.h lÃ­neas 2742-2750
   - Ya existe 5 veces: database_engine.h, DDLExporter, DataGovernance, MetricsCollector, MariaDBToPostgres
   - Usado 45+ veces en este archivo
   - Problema: VIOLACIÃ“N EXTREMA de DRY - misma funciÃ³n 6 veces en proyecto
   - SoluciÃ³n: Consolidar en utils/sql_utils.h (1 sola definiciÃ³n)
   - Beneficio: DRY

ğŸ”´ 4. NO USA ODBCConnection RAII - Resource leaks GARANTIZADOS
   - Archivo: MSSQLToPostgres.h lÃ­neas 68-198 (getMSSQLConnection)
   - Problema: 
     - Retorna SQLHDBC raw pointer
     - closeMSSQLConnection NO se llama (0 ocurrencias encontradas!)
     - SQLHENV no se libera nunca
     - RESOURCE LEAKS CONFIRMADOS
   - SoluciÃ³n: Usar ODBCConnection wrapper ya existente
   - Beneficio: Sin leaks, exception-safe, ~130 lÃ­neas menos
   - IMPACTO: CRÃTICO - leaks acumulativos en producciÃ³n

ğŸ”´ 5. DUPLICACIÃ“N: extractDatabaseName() - YA EXISTE en mssql_engine.cpp
   - Archivo: MSSQLToPostgres.h lÃ­neas 3323-3337
   - Ya existe IDÃ‰NTICO en: mssql_engine.cpp lÃ­neas 143-163
   - Problema: FunciÃ³n duplicada exactamente igual
   - SoluciÃ³n: Usar extractDatabaseName de mssql_engine o ConnectionStringParser
   - Beneficio: DRY, ~15 lÃ­neas eliminadas

ğŸ“‹ PRIORIDAD CRÃTICA - ARQUITECTÃ“NICA:
--------------------------------------
ğŸ”´ 6. DUPLICACIÃ“N: Parseo connection string
   - Archivo: MSSQLToPostgres.h lÃ­neas 77-100 (getMSSQLConnection)
   - Ya existe: ConnectionStringParser::parse()
   - Problema: Duplica parsing (~24 lÃ­neas)
   - SoluciÃ³n: Reutilizar ConnectionStringParser
   - Beneficio: DRY, ~24 lÃ­neas eliminadas

ğŸ”´ 7. SQL INJECTION MASIVO: 45+ vulnerabilities
   - Archivo: MSSQLToPostgres.h mÃºltiples lÃ­neas
   - Ejemplos: 291-292, 876-877, 935-936, 2759-2761, y mÃ¡s...
   - Problema: 45+ usos de escapeSQL() vulnerable
   - SoluciÃ³n: Migrar a prepared statements donde sea posible
   - IMPACTO: VULNERABILIDAD DE SEGURIDAD MASIVA

ğŸ”´ 8. TRANSFORMACIÃ“N toLower DUPLICADA 20+ veces
   - Archivo: MSSQLToPostgres.h
   - Similar a MariaDBToPostgres (25+ veces)
   - SoluciÃ³n: Usar toLower() de utils/string_utils.h
   - Beneficio: DRY, ~40 lÃ­neas eliminadas

ğŸ“‹ RECOMENDACIONES DE CONSOLIDACIÃ“N:
------------------------------------
âœ… ESTRATEGIA: Consolidar MariaDB + MSSQL en arquitectura comÃºn

OpciÃ³n A - Herencia (Recomendado):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DatabaseToPostgresSync (Base)       â”‚
â”‚ - struct TableInfo                  â”‚
â”‚ - getActiveTables()                 â”‚
â”‚ - updateStatus()                    â”‚
â”‚ - cleanValueForPostgres()           â”‚
â”‚ - buildUpsertQuery()                â”‚
â”‚ - buildUpsertConflictClause()       â”‚
â”‚ - Parallel processing infrastructureâ”‚
â”‚ - TRUNCATE/RESET logic              â”‚
â”‚ - PK management                     â”‚
â”‚ (~2000 lÃ­neas comunes)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â–²                    â–²
          â”‚                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MariaDBToPostgresâ”‚  â”‚ MSSQLToPostgres  â”‚
â”‚ (~800 lÃ­neas)    â”‚  â”‚ (~700 lÃ­neas)    â”‚
â”‚ - MySQL specific â”‚  â”‚ - ODBC specific  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OpciÃ³n B - Composition:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SyncOrchestrator                   â”‚
â”‚ - TableSyncManager                 â”‚
â”‚ - BulkDataWriter (comÃºn)           â”‚
â”‚ - StatusManager (comÃºn)            â”‚
â”‚ - Engines polimÃ³rficos             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Beneficios de consolidaciÃ³n:
- Elimina ~2500 lÃ­neas de cÃ³digo duplicado
- Bug fixes se aplican a ambos motores automÃ¡ticamente
- Agregar nuevo motor (Oracle, MongoDB) es fÃ¡cil
- Testing se hace 1 vez, no 2

ğŸ“Š ESTADÃSTICAS CLAVE:
----------------------
- LÃ­neas totales: 3442 (HEADER-ONLY!)
- Responsabilidades: 20+
- CÃ³digo duplicado con MariaDBToPostgres: ~2500 lÃ­neas (70-80%)
- CÃ³digo duplicado interno: ~200 lÃ­neas
- escapeSQL: SEXTA VEZ, 45+ usos
- toLower: 20+ veces
- extractDatabaseName: duplicado de mssql_engine.cpp
- SQL Injection: 45+ lugares
- Resource leaks: closeMSSQLConnection nunca llamado (ODBC handles leaked)

DUPLICACIÃ“N ENTRE MariaDB + MSSQL:
- struct TableInfo: 14 lÃ­neas Ã— 2 = 28 lÃ­neas
- Lambda sorting: 18 lÃ­neas Ã— 2 = 36 lÃ­neas
- getActiveTables: 50 lÃ­neas Ã— 2 = 100 lÃ­neas
- cleanValueForPostgres: ~150 lÃ­neas promedio Ã— 2 = 300 lÃ­neas
- buildUpsert*: 50 lÃ­neas Ã— 2 = 100 lÃ­neas
- Parallel infrastructure: ~500 lÃ­neas Ã— 2 = 1000 lÃ­neas
- LÃ³gica TRUNCATE/RESET: ~200 lÃ­neas Ã— 2 = 400 lÃ­neas
- PK management: ~200 lÃ­neas Ã— 2 = 400 lÃ­neas
- Otros helpers: ~250 lÃ­neas Ã— 2 = 500 lÃ­neas
TOTAL DUPLICADO: ~2864 lÃ­neas entre ambos archivos

REDUCCIÃ“N POTENCIAL:
MariaDBToPostgres: 3989 lÃ­neas
MSSQLToPostgres: 3442 lÃ­neas
TOTAL ACTUAL: 7431 lÃ­neas

CON REFACTORING:
DatabaseToPostgresSync (base): ~2000 lÃ­neas
MariaDBToPostgres (especÃ­fico): ~800 lÃ­neas
MSSQLToPostgres (especÃ­fico): ~700 lÃ­neas
TOTAL REFACTORIZADO: ~3500 lÃ­neas

AHORRO: 7431 - 3500 = 3931 lÃ­neas (-53%)

CALIFICACIÃ“N: ğŸ”´ 2.0/10 - EXTREMADAMENTE RIESGOSO
REQUIERE CONSOLIDACIÃ“N URGENTE CON MariaDBToPostgres

================================================================================

================================================================================
ğŸ”§ MEJORAS TÃ‰CNICAS SUGERIDAS - SYNC (ParallelProcessing.h + StreamingData.h) - 949 lÃ­neas
================================================================================

ğŸ“Š ESTADO ACTUAL:
- ParallelProcessing.h: âœ… EXCELENTE (9.7/10) - NO requiere cambios
- StreamingData.h: ğŸŸ¢ BUENO (7.4/10) - Header-only, duplicaciÃ³n menor
========================================

ğŸ“‹ ParallelProcessing.h (88 lÃ­neas) - ANÃLISIS:
-----------------------------------------------
âœ… EXCELENTE (9.7/10) - NO REQUIERE CAMBIOS

âœ… LO QUE SÃ ESTÃ BIEN (PERFECTO):
----------------------------------
âœ… ThreadSafeQueue<T> correctamente implementado
   âœ… Thread-safety: mutex + condition_variable + atomic
   âœ… Move semantics: evita copias innecesarias
   âœ… RAII locks: lock_guard, unique_lock
   âœ… Timeout configurable en pop()
   âœ… Shutdown graceful con atomic flag + notify_all
   âœ… Template genÃ©rico reutilizable
   âœ… CÃ³digo limpio y simple (88 lÃ­neas)
   
âœ… Structs bien diseÃ±ados (DataChunk, PreparedBatch, ProcessedResult)
   âœ… Nombres descriptivos
   âœ… TamaÃ±o razonable (~5 campos cada uno)

ğŸŸ¢ MEJORAS MENORES (Opcional):
   - Namespace ParallelProcessing podrÃ­a estar anidado
   - Structs podrÃ­an tener constructores explÃ­citos

VEREDICTO: âœ… NO TOCAR - Excelente implementaciÃ³n

================================================================================

ğŸ“‹ StreamingData.h (861 lÃ­neas) - ANÃLISIS:
-------------------------------------------
ğŸ“Š ESTADO: ğŸŸ¢ BUENO (7.4/10) - Orquestador bien diseÃ±ado con mejoras menores

ğŸ“‹ PRIORIDAD CRÃTICA:
---------------------
ğŸ”´ 1. HEADER-ONLY DE 861 LÃNEAS - Separar .h y .cpp
   - Archivo: StreamingData.h (861 lÃ­neas)
   - Problema: Todo en header, ralentiza compilaciÃ³n
   - SoluciÃ³n:
     - include/sync/StreamingData.h (~100 lÃ­neas - declaraciones)
     - src/sync/StreamingData.cpp (~761 lÃ­neas - implementaciones)
   - Beneficio: CompilaciÃ³n mÃ¡s rÃ¡pida

ğŸ“‹ PRIORIDAD ALTA:
------------------
ğŸŸ¡ 2. DUPLICACIÃ“N: ValidaciÃ³n de tablas por engine (3 veces)
   - Archivo: StreamingData.h
   - qualityThread lÃ­neas 559-593 (MariaDB)
   - qualityThread lÃ­neas 595-629 (MSSQL)
   - qualityThread lÃ­neas 631-666 (PostgreSQL)
   - Problema: CÃ³digo EXACTAMENTE IGUAL 3 veces (~35 lÃ­neas Ã— 3 = 105 lÃ­neas)
   - Solo cambia el nombre del engine
   - SoluciÃ³n: Extraer a validateTablesForEngine(conn, dbEngine)
   - Beneficio: DRY, 105 lÃ­neas â†’ 15 lÃ­neas

ğŸŸ¡ 3. DUPLICACIÃ“N: ConfiguraciÃ³n de timeouts (2 veces)
   - Archivo: StreamingData.h
   - qualityThread lÃ­neas 547-548
   - monitoringThread lÃ­neas 807-808
   - Problema: CÃ³digo duplicado
   - SoluciÃ³n: Extraer a setConnectionTimeouts(conn)
   - Beneficio: DRY, ~4 lÃ­neas â†’ funciÃ³n reutilizable

ğŸŸ¡ 4. DUPLICACIÃ“N: PatrÃ³n de threads transfer (2 threads similares)
   - Archivo: StreamingData.h
   - mariaTransferThread: lÃ­neas 459-490
   - mssqlTransferThread: lÃ­neas 492-522
   - Problema: 95% cÃ³digo idÃ©ntico, solo cambian nombres
   - SoluciÃ³n: Template method genericTransferThread()
   - Beneficio: DRY, ~60 lÃ­neas â†’ ~10 lÃ­neas

ğŸ“‹ PRIORIDAD MEDIA:
-------------------
ğŸŸ¢ 5. ValidaciÃ³n de config repetitiva (patrÃ³n similar 4 veces)
   - Archivo: StreamingData.h lÃ­neas 175-242 (loadConfigFromDatabase)
   - chunk_size, sync_interval, max_workers, max_tables_per_cycle
   - Problema: PatrÃ³n duplicado 4 veces (~17 lÃ­neas Ã— 4 = 68 lÃ­neas)
   - SoluciÃ³n: Usar map de validators con min/max/getter/setter
   - Beneficio: DRY, ~68 lÃ­neas â†’ ~20 lÃ­neas, mÃ¡s mantenible

ğŸŸ¢ 6. Empty else blocks
   - LÃ­neas 187, 204 (validaciÃ³n de ranges)
   - SoluciÃ³n: Remover else vacÃ­os
   - Beneficio: CÃ³digo mÃ¡s limpio

âœ… LO QUE SÃ ESTÃ BIEN:
-----------------------
âœ… Arquitectura multi-threaded bien diseÃ±ada
   âœ… 7 threads especializados con responsabilidades claras
   âœ… Shutdown graceful de todos los threads
   âœ… Manejo de excepciones en cada thread

âœ… Usa RAII para conexiones (unique_ptr)
   âœ… pgConn.reset() explÃ­cito despuÃ©s de uso
   âœ… Cleanup automÃ¡tico si hay exception

âœ… ComposiciÃ³n de objetos (no herencia)
   âœ… MariaDBToPostgres mariaToPg
   âœ… MSSQLToPostgres mssqlToPg
   âœ… CatalogManager catalogManager
   âœ… DataQuality dataQuality

âœ… API pÃºblica simple
   âœ… initialize(), run(), shutdown()
   âœ… FÃ¡cil de usar

âœ… ValidaciÃ³n de parÃ¡metros consistente
   âœ… Verifica empty strings
   âœ… Verifica rangos de valores
   âœ… Logging detallado de errores

âœ… Carga dinÃ¡mica de configuraciÃ³n desde BD
   âœ… Permite ajustar sin reiniciar (parcialmente)

ğŸ“Š ESTADÃSTICAS CLAVE:
----------------------
StreamingData.h:
- LÃ­neas totales: 861 (header-only)
- Threads gestionados: 7
- CÃ³digo duplicado: ~170 lÃ­neas (validaciÃ³n tablas + threads)
- ValidaciÃ³n config repetitiva: ~68 lÃ­neas
- Responsabilidades: OrquestaciÃ³n del sistema completo

ParallelProcessing.h:
- LÃ­neas totales: 88
- CÃ³digo duplicado: 0
- Calidad: EXCELENTE

REDUCCIÃ“N POTENCIAL StreamingData.h: 861 â†’ ~690 lÃ­neas (-20%)

CALIFICACIÃ“N GLOBAL SYNC/:
- ParallelProcessing.h: âœ… 9.7/10 - EXCELENTE
- StreamingData.h: ğŸŸ¢ 7.4/10 - BUENO
- MariaDBToPostgres.h: ğŸ”´ 2.2/10 - CRÃTICO
- MSSQLToPostgres.h: ğŸ”´ 2.0/10 - CRÃTICO

CALIFICACIÃ“N PROMEDIO: ğŸŸ¡ 5.3/10 - Muy desbalanceado

TOTAL LÃNEAS CARPETA SYNC: 8379 lÃ­neas
REDUCCIÃ“N POTENCIAL CON CONSOLIDACIÃ“N: ~4400 lÃ­neas (-52%)

================================================================================

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   ğŸ“Š RESUMEN EJECUTIVO GLOBAL DEL PROYECTO                   â•‘
â•‘                         AnÃ¡lisis SOLID + KISS + DRY Completo                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ PROYECTO ANALIZADO: DataSync C++ (11 mÃ³dulos, ~10,000 lÃ­neas)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“Š TABLA COMPARATIVA: CALIDAD POR MÃ“DULO                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MÃ³dulo           â”‚ LÃ­neas â”‚ SOLID   â”‚ DRY â”‚ Security â”‚ Calif.   â”‚ Estado   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ utils/           â”‚    310 â”‚ âœ… 9/10  â”‚ âœ…10â”‚ âœ… 10/10  â”‚ âœ… 9.0/10 â”‚ EXCELENTEâ”‚
â”‚ engines/         â”‚   ~800 â”‚ âœ… 9/10  â”‚ âœ…9 â”‚ ğŸŸ¡ 5/10  â”‚ ğŸŸ¢ 8.0/10 â”‚ MUY BUENOâ”‚
â”‚ catalog/         â”‚   ~600 â”‚ ğŸŸ¡ 7/10  â”‚ âœ…9 â”‚ âœ… 9/10  â”‚ ğŸŸ¢ 7.7/10 â”‚ BUENO    â”‚
â”‚ StreamingData    â”‚    861 â”‚ ğŸŸ¡ 7/10  â”‚ ğŸŸ¡6 â”‚ âœ… 8/10  â”‚ ğŸŸ¢ 7.4/10 â”‚ BUENO    â”‚
â”‚ metrics/         â”‚    591 â”‚ ğŸŸ¡ 6/10  â”‚ ğŸ”´3 â”‚ âœ… 8/10  â”‚ ğŸŸ¡ 5.8/10 â”‚ MEJORABLEâ”‚
â”‚ core/            â”‚   ~250 â”‚ ğŸŸ¡ 5/10  â”‚ ğŸŸ¡6 â”‚ ğŸ”´ 3/10  â”‚ ğŸŸ¡ 4.7/10 â”‚ RIESGOSO â”‚
â”‚ export/          â”‚   1318 â”‚ ğŸ”´ 3/10  â”‚ ğŸ”´4 â”‚ ğŸ”´ 4/10  â”‚ ğŸ”´ 3.5/10 â”‚ RIESGOSO â”‚
â”‚ governance/      â”‚   2178 â”‚ ğŸ”´ 3/10  â”‚ ğŸ”´4 â”‚ ğŸ”´ 4/10  â”‚ ğŸ”´ 3.4/10 â”‚ RIESGOSO â”‚
â”‚ MariaDB sync     â”‚   3989 â”‚ ğŸ”´ 2/10  â”‚ ğŸ”´2 â”‚ ğŸ”´ 3/10  â”‚ ğŸ”´ 2.2/10 â”‚ CRÃTICO  â”‚
â”‚ MSSQL sync       â”‚   3442 â”‚ ğŸ”´ 2/10  â”‚ ğŸ”´2 â”‚ ğŸ”´ 3/10  â”‚ ğŸ”´ 2.0/10 â”‚ CRÃTICO  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PROMEDIO PROYECTO:                                      ğŸŸ¡ 6.0/10           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ¯ PROBLEMAS CRÃTICOS ENCONTRADOS (TOP 10):
============================================

ğŸ”´ 1. DUPLICACIÃ“N MASIVA: MariaDB + MSSQL sync
   - 70-80% cÃ³digo duplicado (~2864 lÃ­neas)
   - Ahorro potencial: 3931 lÃ­neas (-53%)
   - IMPACTO: Bugs duplicados, mantenimiento 2x

ğŸ”´ 2. escapeSQL() DUPLICADO 6 VECES en el proyecto
   - database_engine.h, DDLExporter, DataGovernance, MetricsCollector, 
     MariaDBToPostgres, MSSQLToPostgres
   - Usado 200+ veces en total
   - VULNERABLE a SQL Injection
   - IMPACTO: Seguridad crÃ­tica

ğŸ”´ 3. getCurrentTimestamp() DUPLICADO 3 VECES
   - Logger, DataGovernance, MetricsCollector
   - LÃ³gica idÃ©ntica ~12 lÃ­neas Ã— 3 = 36 lÃ­neas
   - IMPACTO: ViolaciÃ³n DRY

ğŸ”´ 4. TransformaciÃ³n toLower/toUpper DUPLICADA 60+ VECES
   - cluster_name_resolver: 7 veces
   - DataGovernance: 5 veces
   - DataQuality: 1+ veces
   - MetricsCollector: 2 veces
   - catalog_manager: varias veces
   - MariaDBToPostgres: 25+ veces
   - MSSQLToPostgres: 20+ veces
   - TOTAL: ~60+ duplicaciones
   - IMPACTO: CÃ³digo verboso, ~120 lÃ­neas duplicadas

ğŸ”´ 5. Parseo de Connection Strings DUPLICADO 5+ VECES
   - DDLExporter: 2 lugares (MariaDB + MSSQL)
   - cluster_name_resolver: 1 lugar (extractHostname)
   - MariaDBToPostgres: 1 lugar
   - MSSQLToPostgres: 1 lugar
   - Ya existe ConnectionStringParser âœ…
   - IMPACTO: ~125 lÃ­neas duplicadas

ğŸ”´ 6. Password HARDCODEADO en Config.cpp
   - Config.cpp lÃ­nea 8: "Yucaquemada1"
   - VULNERABILIDAD DE SEGURIDAD CRÃTICA
   - Commiteado al repositorio Git
   - IMPACTO: Credenciales expuestas

ğŸ”´ 7. IF-CHAINS MONSTRUOSOS: 388 lÃ­neas de clasificaciÃ³n
   - DataGovernance: determineDataCategory (148 lÃ­neas)
   - DataGovernance: determineBusinessDomain (100 lÃ­neas)
   - DataGovernance: determineSensitivity (80 lÃ­neas)
   - DataGovernance: determineClassification (60 lÃ­neas)
   - LÃ³gica hardcoded, no configurable
   - IMPACTO: Viola OCP, no escalable

ğŸ”´ 8. N+1 Query Problem - 2 lugares
   - DataQuality::checkNullCounts: 1 query por columna
   - MetricsCollector: nested loops O(nÂ²) en 3 mÃ©todos
   - Tabla con 50 columnas = 51 queries
   - IMPACTO: Performance crÃ­tico

ğŸ”´ 9. Memory/Resource Leaks Potenciales
   - DDLExporter: 6 early returns con mysql_close manual
   - MariaDBToPostgres: 8 mysql_close manuales
   - MSSQLToPostgres: ODBC handles nunca liberados (closeMSSQLConnection no se llama!)
   - IMPACTO: Leaks acumulativos en producciÃ³n

ğŸ”´ 10. HEADER-ONLY files gigantes (4 archivos)
   - MariaDBToPostgres.h: 3989 lÃ­neas
   - MSSQLToPostgres.h: 3442 lÃ­neas
   - StreamingData.h: 861 lÃ­neas
   - DDLExporter incluye lÃ³gica en header indirectamente
   - IMPACTO: CompilaciÃ³n extremadamente lenta

ğŸ“Š ESTADÃSTICAS GLOBALES DEL PROYECTO:
======================================
Total lÃ­neas analizadas: ~13,339
CÃ³digo duplicado identificado: ~4,500 lÃ­neas (34%)
SQL Injection vulnerabilities: 200+ lugares
Memory/Resource leaks: 15+ lugares
MÃ©todos >500 lÃ­neas: 3
MÃ©todos >100 lÃ­neas: 20+
Funciones triviales innecesarias: 10+

ğŸ¯ REDUCCIÃ“N POTENCIAL TOTAL:
==============================
ANTES:  ~13,339 lÃ­neas
DESPUÃ‰S: ~7,500 lÃ­neas (aplicando todas las mejoras)
AHORRO: ~5,839 lÃ­neas (-44%)

BENEFICIOS ADICIONALES:
- CompilaciÃ³n ~10-20x mÃ¡s rÃ¡pida
- Sin SQL Injection (migrar a prepared statements)
- Sin memory/resource leaks (RAII everywhere)
- Sin password hardcodeado (variables de entorno)
- Performance ~50-100x mejor (fix N+1, nested loops)
- Testeable (inyecciÃ³n de dependencias, interfaces)

ğŸ† MÃ“DULOS DESTACADOS (Para usar como referencia):
===================================================
âœ… utils/ (9.0/10) - EXCELENTE diseÃ±o, RAII, std::optional, DRY
âœ… ParallelProcessing.h (9.7/10) - Thread-safety perfecto
âœ… engines/ (8.0/10) - Buen uso de interfaces y RAII

ğŸ”´ MÃ“DULOS QUE REQUIEREN ATENCIÃ“N URGENTE:
===========================================
ğŸ”´ sync/MariaDB + MSSQL (2.1/10) - ConsolidaciÃ³n crÃ­tica necesaria
ğŸ”´ governance/ (3.4/10) - God Object, if-chains, N+1 queries
ğŸ”´ export/ (3.5/10) - God Object, duplicaciÃ³n, memory leaks
ğŸ”´ core/Config (4.7/10) - Password hardcodeado, sin cargar de archivo

================================================================================

================================================================================
ğŸ”§ MEJORAS TÃ‰CNICAS SUGERIDAS - ENGINES (database_engine.h + engines/)
================================================================================

ğŸ“‹ PRIORIDAD CRÃTICA (Seguridad - Fix URGENTE):
-----------------------------------------------
ğŸ”´ 1. SQL INJECTION en MariaDB engine
   - Archivos: mariadb_engine.cpp lÃ­neas 152-153, 181-182, 210-211
   - Problema: Usa escapeSQL() que NO es suficiente para prevenir SQL injection
   - SoluciÃ³n A: Usar mysql_real_escape_string() (mÃ­nimo viable)
   - SoluciÃ³n B: Migrar a MySQL Connector/C++ con prepared statements (mejor)
   - MÃ©todos afectados: detectPrimaryKey, detectTimeColumn, getColumnCounts
   - Impacto: VULNERABILIDAD DE SEGURIDAD

ğŸ”´ 2. SQL INJECTION en MSSQL engine
   - Archivos: mssql_engine.cpp lÃ­neas 207, 238-239, 270
   - Problema: Usa escapeSQL() que NO es suficiente
   - SoluciÃ³n: Usar ODBC prepared statements (SQLPrepare + SQLBindParameter)
   - ODBC ya soporta prepared statements nativamente
   - MÃ©todos afectados: detectPrimaryKey, detectTimeColumn, getColumnCounts
   - Impacto: VULNERABILIDAD DE SEGURIDAD

ğŸ”´ 3. Deprecar o eliminar funciÃ³n escapeSQL()
   - Archivo: database_engine.h lÃ­neas 48-56
   - Problema: Solo escapa ', no protege contra \, ", ;, --, /*, binary injection
   - SoluciÃ³n: Marcar como [[deprecated]] y forzar uso de prepared statements
   - Ejemplo vulnerable: admin' OR '1'='1; admin\'; DROP TABLE users; --
   - Beneficio: Prevenir uso inseguro

âœ… NOTA: PostgreSQL engine YA USA prepared statements correctamente (NO vulnerable)

ğŸ“‹ PRIORIDAD ALTA:
------------------
ğŸŸ¡ 4. Extraer utilities a archivo separado
   - Archivo: database_engine.h contiene determinePKStrategy, columnsToJSON, escapeSQL
   - Problema: Utilities no son parte de la interface, violan SRP
   - SoluciÃ³n: Crear engines/database_utils.h para utilities
   - Beneficio: SRP, interface mÃ¡s limpia

ğŸŸ¡ 5. Reutilizar ConnectionStringParser en extractDatabaseName()
   - Archivo: mssql_engine.cpp lÃ­neas 143-163
   - Problema: Duplica lÃ³gica de parsing de connection strings
   - SoluciÃ³n: Usar ConnectionStringParser::parse() existente
   - Beneficio: DRY, menos cÃ³digo duplicado

ğŸŸ¡ 6. Validar timeout setting en MariaDB
   - Archivo: mariadb_engine.cpp lÃ­nea 80
   - Problema: mysql_query() no valida return code
   - SoluciÃ³n: Verificar resultado y loguear warnings si falla
   - Beneficio: Mejor observabilidad de fallos

ğŸ“‹ PRIORIDAD MEDIA:
-------------------
ğŸŸ¢ 7. Considerar migrar MariaDB a library moderna
   - MySQL C API es legacy, considerar MySQL Connector/C++
   - Beneficio: Prepared statements nativos, API mÃ¡s moderna, mÃ¡s seguro
   - Trade-off: Dependencia adicional

ğŸŸ¢ 8. Agregar retry logic en createConnection()
   - Para todos los engines
   - 3 retries con backoff exponencial
   - Beneficio: Resiliencia ante fallos temporales de red

ğŸŸ¢ 9. Agregar connection pooling
   - Reutilizar conexiones en lugar de crear nuevas
   - Beneficio: Performance significativamente mejor
   - Trade-off: Complejidad adicional

âœ… LO QUE SÃ ESTÃ BIEN (No tocar):
----------------------------------
âœ… RAII wrappers (MySQLConnection, ODBCConnection) - PERFECTOS
âœ… Rule of 5 correctamente implementado - No memory leaks posibles
âœ… Move semantics - Eficiente
âœ… Interfaces bien diseÃ±adas (IDatabaseEngine) - Polimorfismo correcto
âœ… PostgreSQL engine usa prepared statements - SEGURO
âœ… Manejo de NULL en resultados - Correcto

================================================================================